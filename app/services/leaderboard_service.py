"""
LeaderboardService - Serves pre-computed leaderboard data.

The backend does NOT calculate leaderboards on the fly.
Leaderboards come from JSON snapshots generated by offline scripts.

This service reads from a leaderboards collection that is populated
by external batch processes.
"""

from typing import Optional

from motor.motor_asyncio import AsyncIOMotorDatabase

from app.models.leaderboard import LeaderboardEntry


class LeaderboardServiceError(Exception):
    """Base exception for leaderboard service errors."""
    pass


class LeaderboardNotFoundError(LeaderboardServiceError):
    """Raised when leaderboard data is not found."""
    pass


class LeaderboardService:
    def __init__(self, db: AsyncIOMotorDatabase):
        self.db = db
        self.collection = db["leaderboards"]

    async def get_global_leaderboard(
        self,
        limit: int = 100,
        year: Optional[int] = None
    ) -> list[LeaderboardEntry]:
        """
        Get global leaderboard (all events).

        Leaderboard data is pre-computed and stored in MongoDB.
        """
        query = {"category": "global"}

        if year:
            query["scope"] = str(year)
        else:
            query["scope"] = "all_time"

        cursor = self.collection.find(query).sort("total_points", -1).limit(limit)
        docs = await cursor.to_list(length=limit)

        return [LeaderboardEntry(**doc) for doc in docs]

    async def get_event_leaderboard(
        self,
        event_id: int,
        limit: int = 100
    ) -> list[LeaderboardEntry]:
        """Get leaderboard for a specific event."""
        query = {
            "category": "event",
            "scope": str(event_id)
        }

        cursor = self.collection.find(query).sort("total_points", -1).limit(limit)
        docs = await cursor.to_list(length=limit)

        return [LeaderboardEntry(**doc) for doc in docs]

    async def get_category_leaderboard(
        self,
        category: str,
        limit: int = 100,
        year: Optional[int] = None
    ) -> list[LeaderboardEntry]:
        """
        Get leaderboard by category.

        Categories: global, main_events, main_card, prelims, early_prelims
        """
        query = {"category": category}

        if year:
            query["scope"] = str(year)
        else:
            query["scope"] = "all_time"

        cursor = self.collection.find(query).sort("total_points", -1).limit(limit)
        docs = await cursor.to_list(length=limit)

        return [LeaderboardEntry(**doc) for doc in docs]

    async def get_user_rank(
        self,
        user_id: str,
        category: str = "global"
    ) -> Optional[dict]:
        """
        Get user's rank in a specific leaderboard category.

        Returns dict with rank and entry data, or None if not found.
        """
        query = {
            "category": category,
            "scope": "all_time",
            "user_id": user_id
        }

        doc = await self.collection.find_one(query)

        if not doc:
            return None

        # Calculate rank by counting users with more points
        rank = await self.collection.count_documents({
            "category": category,
            "scope": "all_time",
            "total_points": {"$gt": doc["total_points"]}
        }) + 1

        return {
            "rank": rank,
            "entry": LeaderboardEntry(**doc)
        }
